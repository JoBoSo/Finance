import pandas as pd
import numpy as np
import datetime as dt
import math
import yfinance as yf # documentation: https://pypi.org/project/yfinance/


# ##############################################################################
# Data Collection + Create DataFrame
# ##############################################################################

# market_data(security, benchmark, start, end, interval) downloads historical
#    market data from Yahoo Finance for both security and benchmark in self.
# Requires: see docstring @ help(FinancialAnalysis.market_data)
# Str Str Str Str Str --> Dataframe
def market_data(security, benchmark, start=None, end=None, interval='1mo'):
    '''
    start/end take the form: "YYYY-MM-DD"
    default start: 5 yrs and one month ago from today
    default end: today
    default interval: '1mo'
    valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo
    '''
    if start is None and end is None:
        today = dt.date.today()
        zero_month = lambda x: True if x != 0 else 12
        start = dt.date(today.year-5, zero_month(today.month-1), today.day).strftime('%Y-%m-%d')
        end = (today).strftime('%Y-%m-%d')
    data = yf.download('{} {}'.format(security, benchmark),  
                       start=start, 
                       end=end, 
                       interval = interval) 
    
    # add intervals returns; note: first item will be None
    ## figure out how to match the other subheadings
    # self.returns() adds the interval returns to self.data
    # Effects: 
    # Str --> DataFrame   
    def returns(ticker):
        returns = [None]
        last = None
        for i, row in data.iterrows():
            curr = row['Adj Close'][ticker]
            if last != None:
                change = (curr - last) / last
                returns += [change]
            last = curr  
        nrows = data.shape[1]
        header = 'Daily Change {}'.format(ticker)
        data.insert(nrows, header, returns, True)
        
    returns(security)
    returns(benchmark)
    
    return data



# ##############################################################################
# Financial Analysis
# ##############################################################################

class FinancialAnalysis:
    '''
    Fields:
       security: stores the security
       benchmark: stores the benchmark for security
       data: stores monthly market data for the last 5 years and 1 month for 
          security and benchmark
    '''
    # FinancialAnalysis(security, benchmark) initiates a FinancialAnalysis obj
    # Str Str --> FinancialAnalysis
    def __init__(self, security, benchmark, start=None, end=None, interval='1mo'):
        self.security = security
        self.benchmark = benchmark
        self.data = market_data(security, benchmark, start, end, interval)
    
    # self.beta() produces the beta regression(slope method) using the data in 
    #    self.data. 
    # beta: FinancialAnalsysis --> Float 
    def beta(self):
        sec_returns = list(self.data['Daily Change {}'.format(self.security)])
        bench_returns = list(self.data['Daily Change {}'.format(self.benchmark)])
        
        # gets (xi-xbar) and (yi-ybar) inputs 
        mean = lambda l: sum(l[1:]) / len(l[1:])
        xbar = mean(sec_returns)
        ybar = mean(bench_returns)
        xs = []
        ys = []
        for i in range(1, len(sec_returns)):
            xs += [sec_returns[i] - xbar]
            ys += [bench_returns[i] - ybar]
        
        # calculates beta regression    
        over = 0
        under = 0
        for i in range(0, len(xs)):
            over += xs[i] * ys[i]
            under += ys[i]**2
        beta_reg = over / under
        return beta_reg        
    
    # intervals per year is used to calculate annual expected market return.
    def capm(self, intervals_per_year):
        # 13 week US T-bill ticker
        Tbill_13wks = yf.Ticker('^IRX')
        # risk free rate
        Rf = Tbill_13wks.info['regularMarketPrice'] / 100 
        # beta of security
        Bi = self.beta()
        # expected markt return = avg return on chosen benchmark based on 
        #    data in self.data.
        bench_returns = list(self.data['Daily Change {}'.format(self.benchmark)])
        ERm = intervals_per_year * sum(bench_returns[1:]) / len(bench_returns[1:])
        # market risk premium
        Rm = ERm - Rf        
        # CAPM = expected return of investment
        capm = Rf + Bi * Rm
        return capm
    
    def sharpe_ratio(self, intervals_per_year):
        # expected return on security
        sec_returns = list(self.data['Daily Change {}'.format(self.security)])
        rp = intervals_per_year * sum(sec_returns[1:]) / len(sec_returns[1:])
        # risk free rate of return
        Tbill_13wks = yf.Ticker('^IRX')
        rf = Tbill_13wks.info['regularMarketPrice'] / 100 
        # standard deviation of returns (risk) of the security
        np_array = fb.data['Daily Change {}'.format(self.security)].values
        sigma_p = np_array[1:].std()
        # sharpe ratio
        sharpe = (rp - rf) / sigma_p
        return sharpe
    
    # Predicts days to liquidate your position assuming you can access 20% of avg daily trade vol
    ## This belongs in portfolio metrics class, once created
    def d2l(self, shares_held):
        ADV = yf.Ticker(self.security).info['averageDailyVolume3Month']
        accessible_ADV = .2 * ADV
        # abs takes into consideration short positions
        D2L = math.ceil(abs(shares_held) / accessible_ADV)
        return D2L
